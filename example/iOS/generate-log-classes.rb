#!/usr/bin/env ruby
# frozen_string_literal: true

ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __dir__)
require 'bundler/setup' if File.exist?(ENV['BUNDLE_GEMFILE'])
require 'daifuku'
require 'erb'
require 'active_support/inflector'
require 'fileutils'

ROOT_PATH = File.absolute_path(File.join(__dir__, '../'))
LOG_DEFINITIONS = File.join(ROOT_PATH, 'LogDefinitions')
TEMPLATE_DIR = File.join(ROOT_PATH, 'iOS/Templates')
GENERATED_CODE_DIR = File.join(ROOT_PATH, 'AutoGenerated')
SWIFT_TYPE_MAPS = {
  'smallint' => 'Int16',
  'integer' => 'Int',
  'bigint' => 'Int64',
  'real' => 'Float',
  'double' => 'Double',
  'boolean' => 'Bool',
  'string' => 'String',
  'date' => 'JSTDateColumn',
  'timestampz' => 'ZonedTimestampColumn'
}
UNSUPPORTED_TYPES = %w(timestamp)

# Represents a Category consisting of multiple events
# ex) Category: RecipeDetail
class CategoryRepresentation
  def initialize(category)
    @category = category
  end

  def name
    @category.name
  end

  def class_name
    @category.name.camelize
  end

  def descriptions
    @category.descriptions
  end

  def variable_name
    @category.name.camelize(:lower)
  end

  def events
    @events ||= @category.events.map { |_, event| EventRepresentation.new(event) }
  end

  def available_events
    events.reject(&:obsolete?)
  end
end

# Represents a Event consisting of multiple columns
# ex) Event: tap_sample_view
class EventRepresentation
  def initialize(event)
    @event = event
  end

  def name
    @event.name
  end

  def variable_name
    @event.name.camelize(:lower)
  end

  def columns
    @columns ||= @event.columns.reject(&:obsolete?).map { |column| ColumnRepresentation.new(column) }
  end

  def descriptions
    @event.descriptions
  end

  def associated_types
    columns.map(&:as_argument)&.join(', ')
  end

  def pattern_matches
    columns.map { |column| column.variable_name.to_string }&.join(', ')
  end

  def availability_annotation
    obsolete? ? '@available(*, unavailable) ' : ''
  end

  def obsolete?
    @event.obsolete?
  end
end

# Represents a column
class ColumnRepresentation
  def initialize(column)
    @column = column
  end

  def variable_name
    @column.name.camelize(:lower)
  end

  def original_name
    @column.name
  end

  def swift_type
    convert_to_swift_type(@column)
  end

  def descriptions
    @column.descriptions
  end

  def as_argument
    "#{variable_name}: #{swift_type}"
  end

  def call_dump
    caller = if @column.type.optional?
               "#{variable_name}?"
             else
               variable_name.to_s
             end
    type = @column.type
    if type.name == 'string' && !type.str_length.nil?
      "#{caller}.validateLength(within: #{type.str_length}).dump()"
    else
      "#{caller}.dump()"
    end
  end

  private

  def convert_to_swift_type(column)
    type = column.type
    raise "Code builder currently doesn't support #{type.name}." if UNSUPPORTED_TYPES.include?(type.name)

    if type.custom?
      swift_type ||= type.name # custom type
    else
      swift_type = SWIFT_TYPE_MAPS[type.name] # primitive types
    end
    if type.optional?
      "#{swift_type}?"
    else
      swift_type
    end
  end
end

# Generating Swift files from Markdown files using Daifuku
class Generator
  def initialize
    check_category_names
    @common_category = categories[COMMON_CATEGORY_NAME]
    raise 'Could not found common category. Please define common.md' unless @common_category
  end

  def generate_common_payload!(destination)
    FileUtils.mkdir_p(File.dirname(destination))
    template = IO.read(File.join(TEMPLATE_DIR, 'CommonPayload.swift.erb'))
    columns = @common_category.common_columns.reject(&:obsolete?).map { |column| ColumnRepresentation.new(column) }
    result = render(template, columns: columns)
    IO.write(destination, result)
  end

  def generate_all_log_categories!(destination)
    FileUtils.mkdir_p(File.dirname(destination))
    template = IO.read(File.join(TEMPLATE_DIR, 'LogCategories.swift.erb'))
    categories_to_generate = categories.map { |_, category| CategoryRepresentation.new(category) }
    result = render(template, categories: categories_to_generate)
    IO.write(destination, result)
  end

  def check_category_names
    # Daifuku uses the file name as the category name, the category name in the Markdown file is simply ignored.
    # But for consistency, here we make sure they are the same.
    Dir.glob(File.join(LOG_DEFINITIONS, '*.md')) do |path|
      content = File.read(path)
      md_category_name = /^#\s*(.+)/.match(content)
      raise "Could not find category name in #{path}" unless md_category_name

      category_name = md_category_name[1]
      file_name = File.basename(path, '.md')
      unless file_name == category_name
        raise %(The file name "#{file_name}" does not match the category name "#{category_name}" in #{path})
      end
    end
  end

  private

  def render(template, hash)
    ERB.new(template, trim_mode: '-').result_with_hash(hash)
  end

  def categories
    @categories ||= Daifuku::Compiler.new.compile(LOG_DEFINITIONS)
  end
end

generator = Generator.new
generator.generate_common_payload!(File.join(GENERATED_CODE_DIR, 'CommonPayload.swift'))
generator.generate_all_log_categories!(File.join(GENERATED_CODE_DIR, 'LogCategories.swift'))
